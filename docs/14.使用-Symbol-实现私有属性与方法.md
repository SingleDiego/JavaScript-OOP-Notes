# 使用-Symbol-实现私有属性与方法

参考：https://www.jianshu.com/p/f40a77bbd74e


<br>
<hr>
<br>


ES6 中引入了一种新的基础数据类型：``Symbol``，它的功能类似于一种标识唯一性的 ID。

每一个 ``Symobl`` 实例都是唯一的，因此，当你比较两个 ``Symbol`` 实例的时候，将总会返回 ``false``：
```
Symbol() === Symbol()
// false
```

由于 ``Symbol`` 是一种基础数据类型，所以当我们使用 ``typeof`` 去检查它的类型的时候，它会返回一个属于自己的类型 ``symbol``，而不是什么 ``string``、``object`` 之类。

```
let s = Symbol()
typeof(s)
// "symbol"
```


<br>
<hr>
<br>


利用 ``Symbol`` 的属性，我们可以实现类的私有变量与私有方法。
```
const _radius = Symbol();

class Circle {
  constructor(radius) {
    this[_radius] = radius;
  };
}

let c = new Circle(1);
```

把实例 c 打印出来看看：
```
Circle {Symbol(): 1}
Symbol(): 1
__proto__: Object
```

属性名变成了 ``Symbol()``，当我们用这个方法设置多个属性名时，外部看全部都是 ``Symbol()``，但彼此之间是不同的。

这种属性在外部是不可见的：
```
Object.getOwnPropertyNames(c)
// []

Object,keys(c)
// []
```

我们查看 c 对象的属性只能得到一个空数组 ``[]``。

要查看这类属性我们使用 ``getOwnPropertySymbols`` 方法：
```
Object.getOwnPropertySymbols(c)
// [Symbol()]
```

<br>
<hr>
<br>


实现私有方法可用以下办法：
```
const _radius = Symbol();
const _draw = Symbol();

class Circle {
  constructor(radius) {
    // 私有属性
    this[_radius] = radius;
  };

  // 私有方法
  [_draw] () {
    console.log('draw');
  };
}

let c = new Circle(1);
```
